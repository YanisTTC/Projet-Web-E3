<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stud’Path - Find student residences and universities with ease">
    <meta name="author" content="Your Name">
    <title>Stud'Path</title>

    <!-- CSS Stylesheets -->
    <link rel="stylesheet" href="assets/styles.css">
    
    <!-- Leaflet.js (Map Library) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!--Link JS Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    
    
    <script>
        "use strict";

        async function fetchSchool() {

            let response = await fetch("/fr-esr-principaux-etablissements-enseignement-superieur@mesr.geojson")
        
            if (!response.ok) {
                throw Error(response.statusText);
            }
            console.log(response.status);
            console.log('pomme')

            let json = await response.json();
            console.log(json);

            return json;

        }

        
        /*****************     Create custumized icons for the markers     *****************/
        
        function createCustomIcon(iconUrl, size = [35, 35]) {
            return L.icon({
                iconUrl,
                iconSize: size, // Default size
                iconAnchor: [size[0] / 2, size[1] / 2], // Center the icon
                popupAnchor: [0, -size[1] / 2] // Position popup above the marker
            });
        }

        
        /*****************     Student Housing     *****************/

        async function fetchHousing() {

            let response = await fetch("/fr_crous_logement_france_entiere@mesr.geojson")

            if (!response.ok) {
                throw Error(response.statusText);
            }
            console.log(response.status);

            let json = await response.json();
            console.log(json);

            return json;

        }
        
        // Store all housing markers for filtering
        let housingMarkers = [];                                
                
        
        /*****************     Create the Popup for each school and student housing     *****************/
        
        function createPopupContent(properties) {
            const photo = properties.photo ? properties.photo.replace(/\\/g, '') : 'assets/default.jpg';

            // Dynamically construct content based on the available properties
            const lines = [];

            if (properties.title || properties.name || properties.uo_lib) {
                lines.push(`<strong>${properties.title || properties.name || properties.uo_lib}</strong><br>`);
            }

            if (properties.phone || properties.numero_telephone_uai) {
                lines.push(`<p><strong>Phone:</strong> ${properties.phone || properties.numero_telephone_uai}</p>`);
            }

            if (properties.address || properties.adresse_uai) {
                lines.push(`<p><strong>Address:</strong> ${properties.address || properties.adresse_uai}</p>`);
            }

            if (properties.services) {
                lines.push(`<p><strong>Services:</strong> ${properties.services}</p>`);
            }

            if (properties.mail) {
                lines.push(
                    `<p><strong>Email:</strong> <a href="mailto:${properties.mail}" target="_blank">${properties.mail}</a></p>`
                );
            }

            if (properties.url || properties.interneturl) {
                const website = properties.url || properties.interneturl;
                lines.push(
                    `<p><strong>Web site:</strong> <a href="${website}" target="_blank">${website}</a></p>`
                );
            }

            // Combine all lines into the popup content
            return `
                <div>
                    <img src="${photo}" alt="Photo" style="width: 100%; height: auto; margin-bottom: 10px;" 
                        onerror="this.src='assets/default.jpg';">
                    ${lines.join('')}
                </div>
            `;
        }

        
        /*****************     Geocode a custom address     *****************/
        
        async function geocodeAddress(address) {
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("Failed to fetch geocoding data");
                }
                const data = await response.json();
                if (data.length > 0) {
                    const { lat, lon } = data[0];
                    return { lat: parseFloat(lat), lon: parseFloat(lon) };
                } else {
                    alert("Address not found. Please try again.");
                    return null;
                }
            } catch (error) {
                console.error("Error in geocoding:", error);
                alert("An error occurred while searching for the address.");
                return null;
            }
        }

        
        /*****************     Calculate distances using OpenRouteService API     *****************/
        
        async function calculateRoute(locations) {
            const apiKey = "5b3ce3597851110001cf6248dbb2adb9062a4c6495d18767be27a734";
            const url = "https://api.openrouteservice.org/v2/directions/driving-car";

            const body = {
                coordinates: locations,
                format: "geojson"
            };

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Accept": "application/json",
                        "Content-Type": "application/json",
                        "Authorization": apiKey
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    throw new Error(`API call failed with status ${response.status}`);
                }

                const data = await response.json();
                console.log("Route Data:", data); // Logs the full API response to the console
                return data;
            } catch (error) {
                console.error("Error fetching Directions API:", error);
                alert("Failed to calculate route. Please try again.");
                return null;
            }
        }

        function decodePolyline(encoded) {
            let index = 0, lat = 0, lng = 0, coordinates = [];
            const factor = 1e5;

            // Loop through the encoded string to extract latitude and longitude deltas
            while (index < encoded.length) {
                let b, shift = 0, result = 0;

                // Decode latitude delta
                do {
                    b = encoded.charCodeAt(index++) - 63; // Convert ASCII to an integer
                    result |= (b & 0x1f) << shift; // Accumulate bits
                    shift += 5;
                } while (b >= 0x20); // Continue until the last byte

                const dlat = (result & 1) ? ~(result >> 1) : (result >> 1); // Convert to signed integer
                lat += dlat; // Update latitude

                shift = 0;
                result = 0;

                // Decode longitude delta
                do {
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);

                const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
                lng += dlng; // Update longitude

                // Store the decoded coordinate
                coordinates.push([lat / factor, lng / factor]);
            }

            return coordinates; // Return array of decoded coordinates
        }

        function displayRouteOnMap(routeData, map, routeKey) {
            console.log("Received Route Data:", routeData);

            if (!routeData || !routeData.routes || routeData.routes.length === 0) {
                console.error("Invalid or empty route data.");
                return;
            }

            const route = routeData.routes[0];
            if (!route.geometry) {
                console.error("Route geometry is missing or malformed.");
                return;
            }

            const routeCoordinates = decodePolyline(route.geometry);
            const distanceInKm = (route.summary.distance / 1000).toFixed(2);

            const routePolyline = L.polyline(routeCoordinates, { color: 'blue' });
            routePolyline.bindTooltip(`Distance: ${distanceInKm} km`, { permanent: false, direction: "top" });

            routePolyline.on("click", function () {
                map.removeLayer(routePolyline); 
                polylines = polylines.filter(polyline => polyline !== routePolyline);
            });

            // Assign the routeKey to this polyline
            routePolyline.routeKey = routeKey;


            routePolyline.addTo(map);
            map.fitBounds(routePolyline.getBounds());

            // Ajoute la polyline à la liste globale
            polylines.push(routePolyline);

            console.log("Route added to map and polylines array:", routePolyline);
            return routePolyline;
        }


        let polylines = [];

        async function calculateDistanceBetweenMarkers(marker1, marker2, map, routeKey) {
            const locations = [
                [marker1.getLatLng().lng, marker1.getLatLng().lat], // [longitude, latitude]
                [marker2.getLatLng().lng, marker2.getLatLng().lat]  // [longitude, latitude]
            ];

            const routeData = await calculateRoute(locations);

            
            const routePolyline = displayRouteOnMap(routeData, map, routeKey); // Get the polyline
            polylines.push(routePolyline); // Store the polyline for future management
                
            

            return routeData;

        }


        // Run once the window is loaded
        window.onload = async () => {
            /*Create a layer with OpenStreetMap tiles */
            let layer = L.tileLayer('https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.{ext}', {
                maxZoom: 25,
                attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                ext: 'png'
            });

            /*Create a map in the previous layer, with a zoom of 9 on the specific coordinates*/
            let map = L.map('map', {
                center: [48.866667, 2.333333],
                zoom: 7,
                layers: [layer]
            });


            let dataSchool = await fetchSchool();
            let dataHousing = await fetchHousing();

            const searchType = document.getElementById("search-type");
            const searchInput = document.getElementById("search_input");
            const form = document.getElementById("search-form");
            const suggestions = document.getElementById("suggestions");
            const distanceList = document.getElementById("distance-list");

            let primaryMarker = null; // Stocke le marker principal

            const sidebar = document.getElementById('sidebar');
            const toggleButton = document.getElementById('sidebar-toggle');

            // verify if the elements exist
            if (sidebar && toggleButton) {
                // display or hide the distances window
                toggleButton.addEventListener('click', () => {
                    sidebar.classList.toggle('collapsed');
                    toggleButton.textContent = sidebar.classList.contains('collapsed') ? '>' : '<';
                });
            } else {
                console.error('Sidebar or toggle button not found!');
            }



            
            let schoolsName = dataSchool.features.map(feature => feature.properties.uo_lib);
            let housingsName = dataHousing.features.map(feature => feature.properties.title);

            // suggestions handling according to the input
            searchInput.addEventListener("input", () => {
                const value = searchInput.value.toLowerCase();
                suggestions.innerHTML = ""; // Reset suggestions

                if (value.length > 0) {
                    let filteredResults = [];
                    if (searchType.value === "school") {
                        filteredResults = schoolsName.filter(school => school.toLowerCase().startsWith(value));
                    } else if (searchType.value === "residence") {
                        filteredResults = housingsName.filter(residence => residence.toLowerCase().startsWith(value));
                    }

                    // 5 suggestions max
                    filteredResults.slice(0, 5).forEach(result => {
                        const suggestionItem = document.createElement("li");
                        suggestionItem.textContent = result;
                        suggestionItem.classList.add("suggestion-item");
                        suggestionItem.addEventListener("click", () => {
                            searchInput.value = result; // Fill the input with  the chosen suggestion
                            suggestions.style.display = "none"; // Hide suggestions
                        });
                        suggestions.appendChild(suggestionItem);
                    });

                    // Display or hide suggestions to suit the results
                    suggestions.style.display = filteredResults.length > 0 ? "block" : "none";
                } else {
                    suggestions.style.display = "none"; // Hide if no results
                }
            });


        // Handle the search type
        searchType.addEventListener("change", () => {
            searchInput.value = ""; // Reset the input
            suggestions.innerHTML = ""; // Erase suggestions
            suggestions.style.display = "none"; // Hide suggestions

            const placeholder = {
                residence: "Enter the name of the residence...",
                address: "Enter a custom address...",
                school: "Enter the name of the school..."
            };
            searchInput.placeholder = placeholder[searchType.value];
        });

        // Handle the submission of the form 
        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const searchValue = searchInput.value;

            if (searchType.value === "school") {
                const matchedSchool = dataSchool.features.find(
                    feature => feature.properties.uo_lib.toLowerCase() === searchValue.toLowerCase()
                );
                if (matchedSchool) {
                    const { geometry } = matchedSchool;
                    if (geometry && geometry.coordinates) {
                        const [lng, lat] = geometry.coordinates;
                        map.setView([lat, lng], 17); // zoom on the school
                        
                    } else {
                        alert("Coordinates not available for the selected school.");
                    }
                } else {
                    alert("No matching school found.");
                }
            } else if (searchType.value === "residence") {
                const matchedResidence = dataHousing.features.find(
                    feature => feature.properties.title.toLowerCase() === searchValue.toLowerCase()
                );
                if (matchedResidence) {
                    const { geometry } = matchedResidence;
                    if (geometry && geometry.coordinates) {
                        const [lng, lat] = geometry.coordinates;
                        map.setView([lat, lng], 17); // zoom on the residence
                    } else {
                        alert("Coordinates not available for the selected residence.");
                    }
                } else {
                    alert("No matching residence found.");
                }
            } else if (searchType.value === "address") {
                //Call the address geocoding function
                const coordinates = await geocodeAddress(searchValue);
                if (coordinates) {
                    const { lat, lon } = coordinates;

                    // Center the map on the location
                    map.setView([lat, lon], 17);

                    const defaultIconUrl = 'assets/marker_click.png';

                    // Add a marker to the location
                    let newMarker = L.marker([lat, lon], { 
                        icon: createCustomIcon(defaultIconUrl),
                        title: searchValue,
                    }).addTo(map);

                    // Add the new marker to the list of markers
                    markers.push(newMarker);

                    onMarkerCreated(newMarker);

                    // add a click event to remove the marker when clicked
                    newMarker.on('click', function () {
                        if (primaryMarker == newMarker) {
                            resetPrimaryMarker();
                        }
                        map.removeLayer(newMarker); // Remove marker from map
                        markers = markers.filter(marker => marker !== newMarker); // Remove marker from the array
                    });
                }

            }
        });

        // Hide suggestions the field loses the focus
        searchInput.addEventListener("blur", () => {
            setTimeout(() => suggestions.style.display = "none", 200); // Délai pour permettre le clic sur une suggestion
        });

        // Display suggestions when the field gains the focus
        searchInput.addEventListener("focus", () => {
            if (suggestions.children.length > 0) {
                suggestions.style.display = "block";
            }
        });

        /*****************     Schools     *****************/

        function createSchoolMarker(feature, latlng) {
            const defaultIconUrl = 'assets/marker_school.png';
            const hoverIconUrl = 'assets/marker_school_hover.png';

            let marker = L.marker(latlng, {
                icon: createCustomIcon(defaultIconUrl),
                title: feature.properties.uo_lib
            });

            // Hover events remain unchanged
            marker.on('mouseover', function () {
                this.setIcon(createCustomIcon(hoverIconUrl, [45, 45]));
                this.setZIndexOffset(1000);
            });
            marker.on('mouseout', function () {
                this.setIcon(createCustomIcon(defaultIconUrl, [35, 35]));
                this.setZIndexOffset(0);
            });

            // Add a click event for route creation
            marker.on('click', function () {
                // If no primary marker is set, this becomes the primary marker
                if (!primaryMarker) {
                    setPrimaryMarker(marker);
                    console.log("Primary marker is now:", primaryMarker.getLatLng());
                } else {
                    // A primary marker already exists; create a route
                    handleRouteCreation(primaryMarker, marker);
                }
            });

            marker.bindPopup(createPopupContent(feature.properties));
            return marker;
        }



        L.geoJSON(dataSchool, {
            pointToLayer: createSchoolMarker
        }).addTo(map);

        
        /*****************     Student Housing     *****************/
        
        // Create housing markers and apply filters
        function createHousingMarkers(dataHousing, map) {
            console.log("Applying filters and creating markers...");

            // Clear existing markers from the map
            housingMarkers.forEach(marker => map.removeLayer(marker));
            housingMarkers = [];

            // Get selected filters (active icons)
            const selectedFilters = Array.from(document.querySelectorAll(".filter-icon.active"))
                .map(icon => icon.getAttribute('data-filter').toLowerCase());
            console.log("Selected filters:", selectedFilters);

            dataHousing.features.forEach(feature => {
                const { geometry, properties } = feature;
                if (geometry && geometry.coordinates && properties.services) {
                    const services = properties.services.toLowerCase();
                    const matchesFilters = selectedFilters.every(filter => services.includes(filter));

                    if (matchesFilters || selectedFilters.length === 0) {
                        const [lng, lat] = geometry.coordinates;

                        const defaultIconUrl = properties.iconUrl || 'assets/marker_housing.png';
                        const hoverIconUrl = properties.hoverIconUrl || 'assets/marker_housing_hover.png';

                        const marker = L.marker([lat, lng], { 
                            icon: createCustomIcon(defaultIconUrl),
                            title: feature.properties.title 
                        });

                        // Hover effect
                        marker.on('mouseover', function () {
                            this.setIcon(createCustomIcon(hoverIconUrl, [45, 45]));
                            this.setZIndexOffset(1000);
                        });
                        marker.on('mouseout', function () {
                            this.setIcon(createCustomIcon(defaultIconUrl, [35, 35]));
                            this.setZIndexOffset(0);
                        });

                        // Click event to set or use the primary marker
                        marker.on('click', function () {
                            if (!primaryMarker) {
                                setPrimaryMarker(marker);
                                console.log("Primary marker is now:", primaryMarker.getLatLng());
                            } else {
                                handleRouteCreation(primaryMarker, marker);
                            }
                        });

                        marker.bindPopup(createPopupContent(properties)).addTo(map);
                        housingMarkers.push(marker);
                    }
                }
            });
        }



        // Toggle the filter when an icon is clicked
        function toggleFilter(event, dataHousing, map) {
            const icon = event.currentTarget; // Get the clicked icon
            const isActive = icon.classList.contains('active'); // Check if the icon is already active

            // Toggle the active state of the icon
            if (isActive) {
                icon.classList.remove('active'); // Remove the active class (filter deactivated)
            } else {
                icon.classList.add('active'); // Add the active class (filter activated)
            }

            // Apply filters based on the active icons
            applyFilters(dataHousing, map);
        }


        // Apply filters to the map based on active icons
        function applyFilters(dataHousing, map) {
            console.log("Applying filters...");
            createHousingMarkers(dataHousing, map); // Recreate housing markers based on the active filters
        }
        
        if (dataHousing) {
            // Initial rendering of markers
            createHousingMarkers(dataHousing, map);

            // Event listener for icon clicks
            document.querySelectorAll(".filter-icon").forEach(icon => {
                icon.addEventListener("click", (event) => {
                    toggleFilter(event, dataHousing, map); // Toggle the filter on icon click
                });
            });
        }
        
        /*****************     Add markers to the map by clicking     *****************/

        // For a new marker created by map click or address search
        function onMarkerCreated(newMarker) {
            // For the hover effect
            const defaultIconUrl = 'assets/marker_click.png';
            const hoverIconUrl = 'assets/marker_click_hover.png';

            newMarker.on('mouseover', function () {
                this.setIcon(createCustomIcon(hoverIconUrl, [45, 45]));
                this.setZIndexOffset(1000);
            });
            newMarker.on('mouseout', function () {
                this.setIcon(createCustomIcon(defaultIconUrl, [35, 35]));
                this.setZIndexOffset(0);
            });

            if (!primaryMarker) {
                setPrimaryMarker(newMarker);
                console.log("Primary marker set:", primaryMarker.getLatLng());
            } else {
                handleRouteCreation(primaryMarker, newMarker);
            }
        }


        // Initialize an array to keep track of all markers
        let markers = [];

        // Map click event to handle marker creation
        map.on('click', (event) => {

            if (event.originalEvent.target.tagName === 'path') {
                console.log("Click on polyline detected, skipping marker creation.");
                return; // Ignore the click if its on a route/polyline
            }

            console.log('Map clicked at:', event.latlng);

            // Get latitude and longitude of the clicked point
            let { lat, lng } = event.latlng;

            console.log(`Creating marker at: ${lat.toFixed(2)}, ${lng.toFixed(2)}`);

            const defaultIconUrl = 'assets/marker_click.png';

            // Create a new marker at the clicked location with the custom icon
            let newMarker = L.marker([lat, lng], {
                icon: createCustomIcon(defaultIconUrl),
                title: `Lat: ${lat}, Lng: ${lng}` // Optional title
            }).addTo(map);

            // Add the new marker to the markers array
            markers.push(newMarker);

            //calls the function to set up the icons and the primary marker
            onMarkerCreated(newMarker);

            // add a click event to remove the marker when clicked
            newMarker.on('click', function () {
                if (primaryMarker == newMarker) {
                    resetPrimaryMarker();
                }
                map.removeLayer(newMarker); // Remove marker from map
                markers = markers.filter(marker => marker !== newMarker); // Remove marker from the array
            });
        });

        /*********** Routes & distances ***/

        // route creation between the last two custom markers
        async function handleRouteCreation(marker1, marker2) {
            if (marker1 === marker2) {
                console.log("Cannot create a route between the same marker.");
                return;
            }

            const routeKey = getRouteKey(marker1, marker2);

            // Check if a route with this key already exists
            const exists = polylines.some(polyline => polyline.routeKey === routeKey);
            if (exists) {
                console.log(`A route between these markers already exists (key: ${routeKey}).`);
                return;
            }

            // Otherwise, calculate and display the route
            const routeData = await calculateDistanceBetweenMarkers(marker1, marker2, map, routeKey);
            if (routeData && routeData.routes && routeData.routes[0]) {
                const route = routeData.routes[0];
                const distanceInKm = (route.summary.distance / 1000).toFixed(2);
                addDistanceToSidebar(marker1, marker2, distanceInKm);
            }
        }

        // return a key that identifies the route between two markers
        // used to verify that a route already exists
        function getRouteKey(markerA, markerB) {
            const latA = markerA.getLatLng().lat.toFixed(5);
            const lngA = markerA.getLatLng().lng.toFixed(5);
            const latB = markerB.getLatLng().lat.toFixed(5);
            const lngB = markerB.getLatLng().lng.toFixed(5);

            // Sort the coordinates as strings 
            const pair1 = `${latA},${lngA}`;
            const pair2 = `${latB},${lngB}`;

            // Return a combined string in alphabetical or numerical order
            return (pair1 < pair2) ? `${pair1}-${pair2}` : `${pair2}-${pair1}`;
        }


        // add the distance in the distance window
        function addDistanceToSidebar(marker1, marker2, distance) {
            const marker1Title = marker1.options.title;
            const marker2Title = marker2.options.title;

            const listItem = document.createElement("li");
            listItem.textContent = `Distance between "${marker1Title}" and "${marker2Title}": ${distance} km`;

            // button to remove the line
            const removeButton = document.createElement("button");
            removeButton.textContent = "Remove";
            removeButton.style.marginLeft = "10px";
            removeButton.onclick = () => {
                listItem.remove(); 
            };

            listItem.appendChild(removeButton);
            distanceList.appendChild(listItem);
        }


        /*****************     Remove all markers and routes by clicking on a button    *****************/

        function removeAllMarkers() {
            markers.forEach(marker => map.removeLayer(marker)); // Remove each marker from the map
            markers = []; // Clear the markers array
        }

        function removeAllPolylines() {
            console.log("Removing all polylines:", polylines);

            polylines.forEach(polyline => {
                map.removeLayer(polyline); 
            });

            polylines = [];

            console.log("All polylines removed.");
        }

        // Add a button to remove all markers
        let removeMarkersButton = L.control({ position: 'topright' });

        removeMarkersButton.onAdd = function () {
            let div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            div.style.backgroundColor = 'white';
            div.style.padding = '5px';
            div.style.cursor = 'pointer';
            div.innerHTML = 'Remove All Markers';

            // Prevent map click events when interacting with the button
            L.DomEvent.on(div, 'click', function (e) {
                L.DomEvent.stopPropagation(e); // Stop click propagation
                removeAllMarkers(); // Call the function to remove all markers
            });

            return div;
        };

        removeMarkersButton.addTo(map);

        // Add a button to remove all markers
        let removePolylinesButton = L.control({ position: 'topright' });

        removePolylinesButton.onAdd = function () {
            let div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            div.style.backgroundColor = 'white';
            div.style.padding = '5px';
            div.style.cursor = 'pointer';
            div.innerHTML = 'Remove All Routes';

            // Prevent map click events when interacting with the button
            L.DomEvent.on(div, 'click', function (e) {
                L.DomEvent.stopPropagation(e); // Stop click propagation
                removeAllPolylines(); // Call the function to remove all routes
            });

            return div;
        };

        removePolylinesButton.addTo(map);
        
        // sets the global primaryMarker and updates the sidebar to show its coordinates.
        function setPrimaryMarker(marker) {
            primaryMarker = marker;
            const markerLatLng = marker.getLatLng();

            // Display primary marker info inside the sidebar
            const primaryInfoDiv = document.getElementById("primary-marker-info");
            if (primaryInfoDiv) {
                primaryInfoDiv.textContent = `Primary Marker: ${marker.options.title}`;
            } else {
                console.warn("Element #primary-marker-info not found in the DOM.");
            }
        }


        function resetPrimaryMarker() {
            primaryMarker = null;
            console.log("Primary marker reset.");

            const primaryInfoDiv = document.getElementById("primary-marker-info");
            if (primaryInfoDiv) {
                primaryInfoDiv.textContent = ``;
            } else {
                console.warn("Element #primary-marker-info not found in the DOM.");
            }
        }

        // Exemple : Ajouter un bouton pour réinitialiser le marker principal
        let resetPrimaryMarkerButton = L.control({ position: 'topright' });

        resetPrimaryMarkerButton.onAdd = function () {
            let div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            div.style.backgroundColor = 'white';
            div.style.padding = '5px';
            div.style.cursor = 'pointer';
            div.innerHTML = 'Reset Primary Marker';

            L.DomEvent.on(div, 'click', function (e) {
                L.DomEvent.stopPropagation(e);
                resetPrimaryMarker();
            });

            return div;
        };

        resetPrimaryMarkerButton.addTo(map);

        }; 
    </script>

</head>
<body>
    <!-- Header Section -->
    <header>
        <nav>
            <h1 id="header-title">Stud’Path</h1>
            <ul>
                <li><a id="home_menu" href="index.html">Home</a></li>
                <li><a id="about_menu" href="about.html">About</a></li>
                <li><a id="report_menu" href="report-english.html"></a>Report</li>
                <li>
                    <div class="language">
                        <select id="language-selector">
                            <option value="en">English</option>
                            <option value="fr">French</option>
                        </select>
                    </div>
                </li>
            </ul>
            
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Search Form -->
        <section class="search-section">
            <h2 id="title"></h2>
            <p id="description"></p>
            <form id="search-form">
                <div id="search-container">
                    <div class="search-label">
                        <label for="search-type" id="search"></label>
                        <select id="search-type" name="search-type">
                            <option id="school_search" value="school" >School</option>
                            <option value="residence" id="student_housing_search">Student Housing</option>
                            <option value="address" id="custom_adsress_search">Custom Address</option>
                        </select>
                    </div>
                    <div class="search-fields">
                        <label for="search_input" id="search_prompt">Type your search:</label>
                        <input type="text" id="search_input" placeholder=" Enter your search... " autocomplete="off" />
                        <!-- suggestions -->
                        <ul id="suggestions" style="position: absolute; z-index: 1000;"></ul>
                    </div>
                    <div class="search-button">
                        <button type="submit" id="search_button">
                            <img src="assets/icons-searchBar/search-icon.png" alt="Search" />
                        </button>
                    </div>
                </div>
            </form>         
        </section>

        <!-- Filters for the Student Housing -->
        <section class="filter-section">
            <div id="filter-student">
                <h3 id="filter">Filter Student housings by Services</h3>
                <div id="filter-icons">
                    <div class="filter-icon" data-filter="wifi">
                        <img src="assets/icons-filter/wifi-3.png" alt="Wifi/Internet" />
                        <p class="filter-label" id="wifi">Wifi/Internet</p>
                    </div>
                    <div class="filter-icon" data-filter="parking">
                        <img src="assets/icons-filter/parking-3.png" alt="Parking" />
                        <p class="filter-label" id="parking">Parking</p>
                    </div>
                    <div class="filter-icon" data-filter="laverie">
                        <img src="assets/icons-filter/laundry-3.png" alt="Laverie" />
                        <p class="filter-label" id="laverie">Laverie</p>
                    </div>
                    <div class="filter-icon" data-filter="sport">
                        <img src="assets/icons-filter/sport-4.png" alt="Sport" />
                        <p class="filter-label" id="sport">Sport</p>
                    </div>
                    <div class="filter-icon" data-filter="handicap">
                        <img src="assets/icons-filter/handicap-1.png" alt="Handicap" />
                        <p class="filter-label" id="handicap">Handicap</p>
                    </div>
                    <div class="filter-icon" data-filter="rest">
                        <img src="assets/icons-filter/restaurant-4.png" alt="Restauration" />
                        <p class="filter-label" id="rest">Restauration</p>
                    </div>
                </div>
            </div>
        </section>
        
        <div id="map-section">
            <div id="sidebar">
                <button id="sidebar-toggle">&lt;</button>
                <h2 id="distance-title">Distances</h2>
                <div id="primary-marker-info"></div>
                <ul id="distance-list">

                </ul>
            </div>
            <div id="map"></div>
        </div>
                    
        
    </main>

    <!-- Footer -->
    <footer>
        <p>&copy; 2025 Stud’Path </p>
    </footer>

    <!-- Language Switcher (English / French) -->
    <script src="language-switcher.js"></script>

</body>
</html>
